---
title: "Temporal network analysis: Introduction, methods and analysis with R" 
format: 
  pdf:
    number-sections: true
    documentclass: article
    papersize: a4
    template-partials:
      - ../../title.tex
    geometry:
      - top = 25.4mm
      - bottom = 25.4mm
      - right = 25.4mm
      - left = 25.4mm
    include-in-header:
      text: |
        \usepackage{lscape}
        \newcommand{\blandscape}{\begin{landscape}}
        \newcommand{\elandscape}{\end{landscape}}
        \usepackage[noblocks]{authblk}
        \renewcommand*{\Authsep}{, }
        \renewcommand*{\Authand}{, }
        \renewcommand*{\Authands}{, }
        \renewcommand\Affilfont{\small}
        \usepackage{float}
        \floatplacement{table}{H}
        \floatplacement{figure}{H}
execute: 
  message: FALSE 
authors:
  - name: Mohammed Saqr (<mohammed.saqr@uef.fi>)
    literal:  Mohammed Saqr <mohammed.saqr@uef.fi>
    affil-id: 1
affiliations:
  - id: 1
    name: University of Eastern Finland
crossref: 
  fig-title: '**Figure**' 
  fig-labels: arabic 
  title-delim: "**.**" 
abstract-title: "Abstract" 
fontsize: "9pt"
dpi: 300 
bibliography: references.bib
abstract: "Learning involves relations, interactions and connections between learners, teachers and the world at large. Such interactions are essentially temporal and unfold in time.  Yet, researchers have rarely combined the two aspects (the temporal and relational aspects) in an analytics framework. Temporal networks allow modeling of the temporal learning processes i.e., the emergence and flow of activities, communities, and social processes through fine-grained dynamic analysis. This can provide insights into phenomena like knowledge co-construction, information flow, and relationship building. This chapter introduces the basic concepts of temporal networks, their types and techniques. A detailed guide of temporal network analysis is introduced in this chapter, that starts with building the network, visualization, mathematical analysis on the node and graph level. The analysis is performed with a real-world dataset. The discussion chapter offers some extra resources for interested users who want to expand their knowledge of the technique."
csl: ../../springer.cls  
keywords: "temporal networks, temporal analysis, social network analysis, learning analytics"
keep-tex: true
extract-media: "img"
---

**Keywords:** {{< meta keywords >}}

# Introduction

Learning is social and therefore, involves relations, interactions and
connections between learners, teachers and the world at large. Such
interactions are essentially temporal and unfold in time
[@Saqr_Lopez-Pernas_2023]; that is, facilitated, curtailed or
influenced at different temporal scales
[@Johnson_Azevedo_DMello_2011;@Saqr_Peeters_Viberg_2021].
Therefore, time has become a quintessential aspect in several learning
theories, frameworks and methodological approaches to learning
[@Chen_Wise_Knight_Cheng_2016;@Reimann_2009;@Saqr_Peeters_Viberg_2021].
Modeling learning as a temporal and relational process is, nevertheless,
both natural, timely and more tethered to reality
[@Chen_Poquet_2020;@Chen_Wise_Knight_Cheng_2016].
Traditionally, relations have been modeled with Social Network Analysis
(SNA) and temporal events have been modeled with sequence analysis or
process mining
[@Lopez-Pernas_Saqr_Gordillo_Barra_2022;@Saqr_Peeters_Viberg_2021].Yet,
researchers have rarely combined the two aspects (the temporal and
relational aspects) in an analytics framework
[@Saqr_Lopez-Pernas_2023]. Considering how important the timing and
order of the learning process are, it is all-important that our analysis
lens is not time-blind
[@Saqr_Lopez-Pernas_2022d;@Saqr_Peeters_2022]. Using time-blind
methods flattens an essentially temporal process where the important
details of progression are lost or distorted
[@Holme_2015;@Holme_Saramaki_2012]. In doing so, we miss the
rhythm, the evolution and devolution of the process, we overlook the
regularity and we may fail to capture the events that matter
[@Holme_2015;@Holme_Saramaki_2012;@Saqr_Peeters_2022].

**Temporal networks**

Recent advances in network analysis have resulted in the emergence of
the new field of temporal network analysis which combines both the
relational and temporal dimensions into a single analytical framework:
temporal networks, also referred to as time-varying networks, dynamic
networks or evolving networks [@Holme_2015]. Today, temporal
networks are increasingly adopted in several fields to model dynamic
phenomena, e.g., information exchange, the spread of infections, or the
reach of viral videos on social media [@Holme_Saramäki_2019].
Whereas temporal networks are concerned with the modeling of
relationships similar to traditional social networks (i.e., static or
aggregate networks), they are conceptually fundamentally different
[@Holme_2015;@Holme_Saramaki_2012;@Nicosia_Tang_Mascolo_Musolesi_Russo_Latora_2013].
Additionally, temporal networks are not a simple extension of social
networks, nor are they time-augmented social networks or time-weighted
networks. In that, temporal networks are based on
different representations of data, have a different mathematical
underpinning, and use distinct visualization methods. In temporal
networks, edges emerge (get activated or born) and dissolve (get
deactivated or die) compared to always present edges in  static social networks.
Also, in temporal networks, an edge represents temporary interaction, contact,
co-presence, or concurrency between two nodes interacting at a specific
time. The fact that static networks represent nodes as being connected
together all the time exaggerates connectivity
[@Li_Cornelius_Liu_Wang_Barabási_2017;@Saqr_Nouri_2020]. For
instance, in @fig-interactions, we have five network visualizations, each network
belonging to a weekday. We see that Monday, Tuesday, and Wednesday
networks are relatively connected, whereas Thursday and Friday networks
are disconnected. The corresponding aggregated or static network on the
right is densely connected. The example in @fig-interactions shows how a
static network both conflates connectivity and obfuscates dynamics, you
can read more about this example in [@Saqr_Nouri_2020]. Similarly, network measures calculated in
static networks are inflated and biased -skewed towards higher values - because they ignore the temporal direction of edges  allowing the edges to run back in time. Another characteristic of temporal networks is that edges have a starting time
point and ending time point, the end of each edge is understandably
later than the start, i.e., follows the forward-moving direction of
time. Therefore, the paths in the temporal network are
unidirectional or time-restricted
[@Holme_2015;@Holme_Saramaki_2012]. The next section discusses
the temporal networks in detail.


![Interactions are aggregated per day showing that some days
show an active group e.g., Monday, and other days have an inactive group
e.g., Friday. Meanwhile, the static network on the right appears dense [@Saqr_Nouri_2020]](./image1.png){#fig-interactions width="6in"
fig-align="center"}




# The building blocks of a temporal network 

## Edges

In temporal networks, edges are commonly referred to as events, links,
or dynamic edges. Two types of temporal networks are commonly described
based on their edge type [@Holme_Saramäki_2019].

-   **Contact temporal networks:** In contact temporal networks, edge
    duration is very brief, undefined, or negligible. For example,
    instant messages have no obvious duration but have a clear source
    (sender), target (receiver), and timestamp. @fig-contact shows a contact
    temporal network where the edges are represented as sequences of
    contacts between nodes with no duration.

![Example of a contact temporal network. Edges form momentarily
and have no obvious duration.](./image2.png){#fig-contact width="4.5in" fig-align="center"}

-   **Interval temporal networks:** In interval temporal networks, each
    interaction has a duration. An example of such a network would be a
    conversation where each of the conversants talks for a certain
    length of time. In the interval temporal network, the duration of
    interactions matters and the modeling thereof helps understand the
    process. In @fig-interval, we see an interval temporal network where each
    edge has a clear start and clear end. For example, an edge forms
    between node A and node B at time point 1 and dissolves at time
    point 3, i.e., lasts for two time points.

![An example of an interval network. On the top, we see an
example of an edge. In the bottom arrows pointing to two edges B-D and
A-D, we can see that the two edges do not overlap and therefore,
although they share a connection (A), we can't assume that B is
connected to A through D.](./image3.png){#fig-interval width="4.5in"  fig-align="center"}


## Paths, concurrency, and reachability

Paths represent the pathways that connect edges, the identification of
which can help solve essential problems like the shortest path between
two places in a route planning application, e.g., Google maps. In a
dynamic process, the paths represent a time-respecting sequence of edges
i.e., where the timing of each edge follows one another according to
time passage, that is, the timestamps are incrementally increasing
[@Holme_2015;@Holme_Saramaki_2012]. For instance, let's assume we
have a group of students interacting about a problem, starting by
defining the problem, argumenting, debating, and finding a solution. The
temporal path that would represent the sequence of interactions among
students in this process will be a
*defining*->*argumenting*->*debating*->*solving*. We expect that the
timestamp of *defining* precedes *argumenting* and *argumenting*
precedes *debating* and so on. In that way, the path is unidirectional,
follows a time-ordered sequence, and requires that each node is
temporally connected, i.e., the two nodes coexist or interact with each
other at the same time [@Holme_Saramaki_2012]. Such temporal
co-presence is known as concurrent. Concurrency defines the duration of
the nodes where they were co-present together and therefore can be a
measure of the magnitude of contact between the two nodes. This is
particularly important when we are modeling processes where the path length matters e.g., social influence. A student is more likely
to be influenced by an idea when the student discusses the idea with
another for a longer period of time. Similarly, self-regulation could be
more meaningful when phases are more concurrent rather than disconnected
[@Saqr_Peeters_Viberg_2021]. Reachability is the proportion of nodes that can be reached from a node using time-respecting paths. A node is more influential or central, if it can reach a larger number of nodes [@Holme_Saramäki_2019]. 

## Nodes

Nodes in temporal networks are similar to static networks at large. Such nodes can be humans, objects, semantics, historical events or chemical reactions to mention a few. Perhaps, the possible difference ---if it at all exists--- is that temporal network tend to be studied in fields where temporal order is consequential e.g., epidemics, linguistics and spread of ideas.

# Previous work and examples of temporal network analysis

Few studies have addressed temporal network analysis. Yet, some examples
exist that may shed light on the novel framework and how it can be
harnessed in education. In a study by Saqr and Nouri
[@Saqr_Nouri_2020], the authors investigated how students interact
in a problem-based learning environment using temporal networks. The
study estimated temporal centrality measures, used temporal network
visualization, and examined the predictive power of temporal centrality
measures. The study reported rhythmic changes in centrality measures,
network properties as well as the way students mix online. The study
also found that temporal centrality measures were predictive of
students" performance from as early as the second day of the course.
Models that included temporal centrality measures have performed
consistently better and from as early as the first week of the course.
Another study by @Saqr_Peeters_2022 analyzed students'
interactions in an online collaborative environment where students
interacted in Facebook groups. The authors compared centrality measures
from traditional social networks to temporal centrality measures and
found that temporal centralities are more predictive of performance.
Another study from the same group has used chat messages to study how
students interact online and how temporal networks can shed light on
different dynamics of students interacting using Discord instant
messaging platform compared to students interacting using the forums in
Moodle. Temporal networks were more informative in capturing the
differences in dynamics and how such dynamics affected students" way of
communicating [@Saqr_Lopez-Pernas_2022a].

# Tutorial: Building a temporal network

Temporal network is a relatively new field with an emerging repertoire of methods that are continuously expanding. As we currently stand, a coherent tutorial that combines all possible steps of the analysis does not exist, and that is what this chapter aims to fill. The tutorial will introduce the R packages, visualization and mathematical analysis  e.g., graph  and node level centrality measures.  
The first step is to load the needed packages. Unlike the SNA chapter [@Saqr_Angel2024] where we relied on the `igraph` framework, we will rely on  the `statnet` framework that has a rich repertoire of temporal network packages. We will use three main packages, namely `tsna` (Temporal Social Network Analysis) which provides most functions for dealing with temporal networks as an extension for the popular `sna` package. The package `networkDynamic` offers several complementary functions for the network manipulation, whereas the package `ndtv` (Network Dynamic Temporal Visualization) offers several functions for visualizing temporal networks. To learn more about these packages, please visit their help pages. The next code chunk loads these packages as well as `tidyverse` packages to process the network dataframe [@Bender-deMoll_2016,@Bender-deMoll_2018;@Bender-deMoll_Morris_2016]. We also need `tidyverse` for manipulating the file and preparing the data.

```{r, results=F, warning=F, message=F}
library(tsna)
library(ndtv)
library(networkDynamic)
library(tidyverse)
library(rio)
```

To create a temporal network, we need a timestamped file with
interactions. The essential fields are the `source`, `target` and
`time`, and perhaps also some information about the interactions or the
nodes (but these constitute extra information that is good to have). A
temporal network is created by combining a base static network (that has
the network base information) and a dynamic network with time
information. As such, we need to prepare the Massive Open Online Course (MOOC) dataset described in
detail here [@Lopez-Pernas_Saqr_Del] and prepare it for
creating a static network that will serve as a base network.

The next code chunk loads the dataset files (edges and nodes data) from
the MOOCs dataset. Some cleaning of the data is necessary. 
\scriptsize
```{r}
net_edges <- import("https://raw.githubusercontent.com/lamethods/data/main/6_snaMOOC/DLT1%20Edgelist.csv")
net_nodes <- import("https://raw.githubusercontent.com/lamethods/data/main/6_snaMOOC/DLT1%20Nodes.csv")
```
\normalsize
First, we have to clean the column names from extra spaces using the function
`clean_names` from the `janitor` package. Next, we have to remove
loops, or instances where the source and target of the interaction are
the same since it makes little sense that a person responds to oneself
in a temporal network (this is not essential). Third, we need to create
a dataframe where we replace duplicate edges with a weight equal to the
frequency of repeated interactions, we will need this file for the
creation of the base network (see later). Fourth, we recode the
expertise level in the nodes file to meaningful codes (from its original
numerical coding as 1,2,3) so that we can use them later in the
analysis. The fifth step is to convert the timestamp to sequential days
starting from the first day of the course; this makes sense for easy
interpretation. Also, time works better in networkDynamic when it is
numeric. The final step is to remove discussions where there are no
replies. This cleaning is necessary since we have a dataset that was not
essentially prepared for temporal networks.

```{r}
net_edges <- net_edges |> janitor::clean_names() #1 cleaning column names
net_edges_NL <- net_edges |> filter(sender != receiver) #2 removing loops

# Removing duplicates and replacing them with weight
net_edges_NLW <- net_edges_NL |> group_by(sender, receiver) |> tally(name = "weight") #3

# Recoding expertise
net_nodes <- net_nodes |> 
  mutate(expert_level = case_match(experience, #4
        1 ~"Expert",
        2 ~ "Student",
        3 ~ "Teacher"))

# A function to create serial days
dayizer = function(my_date) {
  numeric_date = lubridate::parse_date_time(my_date, "mdy HM")
  Min_time = min(numeric_date)
  my_date = (numeric_date - Min_time) / (24*60*60)
  my_date = round(my_date,2)
  return(as.numeric(my_date))
}

net_edges_NL$new_date = dayizer(net_edges_NL$timestamp) #5

# Remove dicussions with no interactions
net_edges_NL <- net_edges_NL |> group_by (discussion_title) |> filter(n() > 1)
```


As mentioned before, the first step in creating a temporal network is
creating a static base network (base network) which carries all the
information about the network, e.g., the nodes, edges as well as their
attributes. The base network is typically a static weighted network.
Here we define the base network file (the weighted edge file we created
before), we use `directed = TRUE` to create our network as directed and we
tell the `network` function that the vertices attributes are in the
net_nodes file.

```{r}
NetworkD <- network(net_edges_NLW, directed = TRUE, matrix.type = "edgelist", 
                    loops = FALSE, multiple = FALSE, vertices = net_nodes)
```


For creating a temporal network, we need more than the source and the
target commonly needed for the static network. In particular, the
following variables are required to be defined.

-   `tail`: the source of the interaction

-   `head`: the target of the interaction

-   `onset`: The starting time of the interaction

-   `terminus`: the end time of the interaction

-   `duration`: the duration of the interaction

Our dataset ---which comes from forum MOOC interactions, see @fig-edges-file---
has an obvious starting time (which is the timestamp of each
interaction) but has no clear end time. There is no straightforward
answer to this question. Nonetheless, a possible way to consider the
duration of every post is the duration the post was active in the
discussion or continued to be discussed. That is the time from the post
in a discussion thread to the last post in the same threads of replies.
Such a method ---while far from perfect--- offers a rough method for
estimating the time during which this interaction has been "active" in
the discussion [@Saqr_Nouri_2020;@Vu_Pattison_Robins_2015]. For
an illustration, see @fig-discussion which shows the duration for the first
and second posts. 

![Screenshot of the edges file. The edge file has source (sender), target (receiver) and a timestamp](./image4.png){width="6.5in" height="2.1805555555555554in" #fig-edges-file}


![A sample discussion demonstrating a way to compute the duration of the post. The first post lasts active in the discussion from starting time to the last reply it stimulated in the same thread (D1)](./image5.png){width="5.243055555555555in"
height="2.8904024496937883in" #fig-discussion}

The next code chunk creates a variable for the
starting time of each interaction, computes the ending time where this
post was part of an active discussion, and then computes the duration.

```{r}
# Create the required variables (start, end, and duration) defined by

net_edges_NL <- net_edges_NL |> group_by(discussion_title) |>
mutate(start = min(new_date), end = max(new_date), duration = end - start)
```

In the same way, the second duration is computed in the same way (D2).
The next step of the analysis creates a dataframe where all the needed
information for the network is specified and in the next step we simply
use the `networkDynamic` with two arguments, the base network and the
dataframe with all the temporal network information created in the
previous step. Nonetheless, dealing with around 450 nodes in a network
is hard, it becomes impossible to visualize or get insights from a large
number of crowded nodes. So, for the sake of simplicity of demonstration
in this tutorial, we will create a smaller subset of the network of
people who had a reasonable number of interactions (degree more than 20)
using `get.inducedSubgraph` argument. The resulting network is then
called `Active_Network` which we will analyze.

```{r}
# Creating a dataframe with needed variables

edge_spells <- data.frame("onset" = net_edges_NL$start ,
                         "terminus" = net_edges_NL$end, 
                         "tail" = net_edges_NL$sender, 
                         "head" = net_edges_NL$receiver, 
                         "onset.censored" = FALSE,
                         "terminus.censored" = FALSE, 
                         "duration" = net_edges_NL$duration)

# Creating the dynamic network network
Dynamic_network <- networkDynamic(NetworkD, edge.spells = edge_spells)

Active_Network <- get.inducedSubgraph(Dynamic_network,
                                v = which(degree(Dynamic_network) > 20))
```

We can then confirm that the network has been created correctly using
the `print` function. As the output shows, we have 521 distinct time
changes, 72 days, 445 vertices and 1936 edges. We can also use the
function `plot` to see how the network looks. The argument `pad` helps us remove the additional whitespace around the network. Plotting a temporal
network helps summarize all the interactions in the network. As we can
see in @fig-full-network, the network is dense with several edges between
interacting students.

```{r, fig.cap="A plot of the full network as plotted by the plot function.", fig.align="center",fig.width=6, fig.height=6, fig.dpi=800}
#| label: fig-full-network
print(Dynamic_network)
plot.network(Active_Network, pad = -0.5)
```


## Visualization of temporal networks 

To take advantage of the temporal network, we can use a function to
extract the network at certain times to explore the activity. In the
next example in @fig-plot-weeks, we chose the first four weeks one by one and
plotted them alongside each other. The function `filmstrip` can create
a similar output with a snapshot of the network at several time
intervals. A similar result, yet with
three-dimensional placing, can also be obtained with the `timePrism`
function, as shown in  @fig-timeprism. You may need to consult the package
manual to get more information about the arguments and options for the
plots.


```{r,fig.cap="A plot of the network at weeks 1, 2, 3, and 4", fig.align="center",fig.width=20,fig.height=5.5, echo=2:5, fig.dpi=700}
#| label: fig-plot-weeks
par(mfcol = c(1,4))
plot.network(network.extract(Active_Network, onset = 1, terminus = 7))
plot.network(network.extract(Active_Network, onset = 8, terminus = 14))
plot.network(network.extract(Active_Network, onset = 15, terminus = 21))
plot.network(network.extract(Active_Network, onset = 22, terminus = 28))
```

 

```{r, message=F, warning=F, fig.cap="A three-dimensional visualization of the network as a sequence of snapshots in space and time prism", fig.align='center',fig.width=8,fig.height=4}
#| label: fig-timeprism
compute.animation(Active_Network)

timePrism(Active_Network, at = c(1, 7, 14, 21),
  spline.lwd = 1,
  box = TRUE,
  angle = 60,
  axis = TRUE,
  planes = TRUE,
  plane.col = "#FFFFFF99",
  scale.y = 1,
  orientation = c("z", "x", "y"))
```

 

However, a better way is to take advantage of the capabilities of the
package `ndtv` and the network temporal information by rendering a full
animated movie of the network as in @fig-movie and explore each and every
event as it happens.

```{r, eval=F}
render.d3movie(Active_Network)
```
 

![A screenshot of the animated movie of the temporal network](./image9.png){width="4.640625546806649in" height="2.878079615048119in" #fig-movie}



As we mentioned in the introduction section, in temporal networks, edges
or relationships form "get activated" and dissolve "get deactivated". We
can plot such the dynamic edge formation and dissolution process using
the functions `tEdgeFormation` which as the name implies plots the
edges forming at the given time point. The function `tEdgeDissolution`
returns the edges terminating and can be plotted in the same way as seen
in @fig-edges. Obviously, at the beginning of the MOOC, we see new
relationships form and, at the end, most relationships dissolve.

```{r,layout = c(1,1), fig.align="center",fig.width=7,fig.height=4.3, fig.cap="Edge formation and dissolution. We see that edge formation occurs towards the start and increases till almost t=50 and edge dissolution starts scanty at the beginning and increases with time, peaking at t=70"}
#| label: fig-edges
#| fig-subcap:
#| -  Edge formation
#| -  Edge dissolution

plot(tEdgeFormation(Active_Network, time.interval = 0.01), ylim = c(0,50))
plot(tEdgeDissolution(Active_Network, time.interval = 0.01), ylim = c(0, 50))
```

Another way to visualize a temporal network is to use the proximity
timeline, the `proximity.timeline` function tries to draw the temporal network
in two dimensions, that is, it draws nodes at each time point taking
into account how closely connected they are and renders them
accordingly, nodes that are interacting are rendered close to each
other, and nodes that not interacting are rendered apart. Technically as
described in the function manual: "The passed network dynamic object is
sliced up into a series of networks. It loops over the networks,
converting each to a distance matrix based on geodesic path distance
with `layout.distance`. The distances are fed into an MDS algorithm
(specified by mode) that lays them out in one dimension: essentially
trying to position them along a vertical line. The sequence of 1D
layouts are arranged along a timeline, and a spline is drawn for each
vertex connecting its positions at each time point. The idea is that
closely-linked clusters form bands of lines that move together through
the plot" [@Bender-deMoll_2018]. The result is a timeline of
temporal proximity. The next code draws the proximity timeline but also
adds some colors, and a start and end for the plot, see the result in
@fig-prox-timeline.

```{r, fig.cap="A proximity timeline shows connected interacting nodes closer to each other.", fig.align="center", message=F, fig.height=4, fig.width=7}
#| label: fig-prox-timeline
proximity.timeline(Active_Network, default.dist = 1, mode = "sammon",
                   labels.at = 1, vertex.col = grDevices::colors(),
                   start = 1, end = 30, label.cex = 0.5)
```


## Statistical analysis of temporal networks 

### Graph level measures

Graph properties in temporal networks are dynamic and vary by time. When
graph measures are computed we get a time series of the computed
measures. Such fine-grained measures allow us to understand how the
networks and their structure evolve or unfold in time and thus, such
information can help us understand collaboration or interaction dynamics
as they occur [@Saqr_Nouri_2020;@Saqr_Peeters_2022].

The function `tSnaStats` from the package `tsna` has a large number of
measures that can be computed by specifying the argument `snafun`. In
the next example, we compute the graph level density with the argument
`snafun=gden.` The function allows the choice of a range of time, for
instance, from the end of the second week to the end of second month by
supplying the arguments `start = 14` to `end = 60`. We can also use the
`time.interval` to specify the granularity of the calculation. The
argument `aggregate.dur` specifies the period of the aggregation, for
instance, `aggregate.dur = 7` will compute the density for every seven
days. We can also plot the density time series by simply using the
function `plot`. 


```{r, fig.cap="A plot of temporal density from t=14 to t=60", fig.align="center"}
#| label: fig-temporal-density
Density <- tSnaStats(
  nd = Active_Network,
  snafun = "gden",
  start = 14,
  end = 60,
  time.interval = 1,
  aggregate.dur = 7)
plot(Density)
```
You can see, in the resulting graph in @fig-temporal-density,
that the density increases until day 50 and then starts to drop. Of
note, another type of density can be computed, known as temporal
density, which computes the observed total duration of all edges and
divides it by the maximum duration possible. Temporal density can be
computed using the command `tEdgeDensity`.
```{r}
tEdgeDensity(Active_Network) 
gden(Active_Network) 
```

Similar to density, we can compute reciprocity, i.e., the ratio of
reciprocated edges to asymmetric edges. Note, that we calculate
reciprocity here from day 1 to day 73 on a daily basis (this is just for
demonstration of different periods). Since the function default is to
calculate the reciprocated dyads, we specify the argument *measure =
"edgewise"* to calculate the proportion of reciprocated edges. As the
graph in @fig-several (a) shows, reciprocity increases steadily for the first
50 days pointing to a build up of trust between collaborators. The
`dyad.census` function offers a more granular view of the dyads and
their reciprocity as shown in @fig-several (b). Similarly, `mutuality` is a
very similar function and returns the number of complete dyads
(reciprocated dyads), plotted in @fig-several (c). All of the aforementioned
functions deal with reciprocity, for differences
and usages, readers are encouraged to read the functions' help to
explore the differences, arguments as well as the equation for each
function.

```{r, layout=c(1,1,1), fig.cap="Network descriptive statistics over time"}
#| label: fig-several
#| fig.subcap:
#|   - "Reciprocity over time"
#|   - "Dyad census over time"
#|   - "Mutuality over time"
Reciprocity <- tSnaStats(
    nd=Dynamic_network,
    snafun = "grecip" ,
    start = 1,
    end = 73,
    measure = "edgewise",
    time.interval = 1,
    aggregate.dur = 1)
plot(Reciprocity)

Dyad.census <- tSnaStats(Active_Network, 
                         snafun = "dyad.census")
plot(Dyad.census)

dynamicmutuality <- tSnaStats(
  Active_Network,
  snafun = "mutuality",
  start = 1,
  end = 73,
  time.interval = 1,
  aggregate.dur = 1
  )
plot(dynamicmutuality)
```
 
Centralization measures the dominance of members within the network and
can be traced temporally using the function snafun = "centralization".
Please note that we can choose the period, the interval and the
aggregation periods using function arguments as mentioned before. The
next example computes the degree centralization as demonstrated in
@fig-deg-centr. Also note that we can also compute other centralization
measures such as centralization indegree, centralization outdegree,
centralization betweenness, centralization closeness and eigenvector.

```{r, fig.cap="A plot of degree centralization over time", fig.align="center",fig.width=7,fig.height=5}
#| label: fig-deg-centr

Degree_centralization <- tSnaStats(
  Active_Network,
  snafun = "centralization",
  start = 1,
  end = 73,
  time.interval = 1,
  aggregate.dur = 1,
  FUN = "degree")

plot(Degree_centralization)
```

Several other graph-level measure can be computed in the same way using
the following arguments passed to the `snafun`:
  -   `components`: count of Components within the graph over time
  -   `triad.census`: the triad census and types of triads over time
  -   `connectedness`: the connectedness score of the network efficiency network efficiency over time
  -   `gtrans`: network transitivity over time
  -   `hierarchy`: network Hierarchy over time
  -   `lubness`: network LUBness over time
  -   `efficiency`: network efficiency over time
  -   `hierarchy`: network hierarchy over time


### Node-level measures (Temopral centrality measures)

Centrality measures has been used to identify important actors, as a proxy
indicator for academic achievement or to identify students'
collaborative roles
[@Hernández-García_González-González_Jiménez-Zarco_Chaparro-Peláez_2015;@Poquet_Saqr_Chen_2021;@Saqr_Elmoazen_Tedre_Lopez-Pernas_Hirsto_2022;@Saqr_Lopez-Pernas_2022c].
In temporal networks, centrality measures are fine-grained estimates of
students" real-time centralities or importance, i.e., shows who were
central and when considering the temporarily of their interaction. In
doing so, we can see exactly when and for how long, at what pace, and
with which rhythm a behavior happens (compare this to traditional social
network analysis where centralities are computed as a single number).
There are several possible uses of temporal centrality measures. For
instance [@Saqr_Nouri_2020] have used them to create predictive
models of students' performance. In another study by the same authors,
they demonstrated that temporal centrality measures were more predictive
of performance compared to traditional static centrality measures
[@Saqr_Peeters_2022]. Since the temporal centralities are computed
as time series, their temporal characteristics can also be used to
compute other time series properties e.g., stability, variabilities, and
pace, you can see for example [@Saqr_Nouri_2020]. There is a
growing list of temporal centrality measures e.g.,
[@Nicosia_Tang_Mascolo_Musolesi_Russo_Latora_2013]. We will
study here the most commonly used ones according to the latest review
[@Saqr_Elmoazen_Tedre_Lopez-Pernas_Hirsto_2022], but readers are
encouraged to explore the `tsna` manual for more centrality measures.

Temporal degree centrality measures can be computed in the same way as
we computed the graph level properties shown before. The next code
defines the function `snafun = "degree"`, the start, the end date, and
aggregation (which you can modify). An important argument here is the
`cmode` argument which defines the type of centrality: "freeman",
"indegree" or "outdegree" for the calculation of total in or out degree
centralities. The result is a time series with the 73 values for each
day from start to end, each day having a unique value for the degree
centrality for each node. The rest of the code is intended to organize
the results. We convert the time series to a dataframe, create a
variable for the day number to make it easier to identify the day and
create a variable to define the type of centrality, and then combine all
centrality measures into a single data frame as below.

```{r, results = F}
Degree_Centrality <- tSnaStats(
  Active_Network,
  snafun = "degree",
  start = 1,
  end = 73,
  time.interval = 1,
  aggregate.dur = 1,
  cmode = "freeman")

inDegree_Centrality <- tSnaStats(
  Active_Network,
  snafun = "degree",
  start = 1,
  end = 73,
  time.interval = 1,
  aggregate.dur = 1,
  cmode = "indegree")

OutDegree_Centrality <- tSnaStats(
  Active_Network,
  snafun = "degree",
  start = 1,
  end = 73,
  time.interval = 1,
  aggregate.dur = 1,
  cmode = "outdegree")

Degree_Centrality_DF <- Degree_Centrality |> as.data.frame() |> 
  mutate(Day = 1:73, centrality = "Degree_Centrality", .before = 1L)


inDegree_Centrality_DF <- inDegree_Centrality |> as.data.frame() |> 
  mutate(Day = 1:73,centrality = "inDegree_Centrality", .before = 1L)


OutDegree_Centrality_DF <- OutDegree_Centrality |> as.data.frame() |> 
  mutate(Day = 1:73,centrality = "OutDegree_Centrality", .before = 1L)

rbind(Degree_Centrality_DF, inDegree_Centrality_DF, OutDegree_Centrality_DF) 
```
```{r, echo = F}
rbind(Degree_Centrality_DF, inDegree_Centrality_DF, OutDegree_Centrality_DF)  |> as_tibble()
```

 
In the same way, closeness, betweenness and eigenvector centralities can
be computed. Please note that we have a new argument here
`gmode="graph"` which tells `snafun` that we would like to compute
these centralities considering the network as undirected. You can also
use the `gmode="digraph"` to compute the measures on a directed basis.
You may need to use the previous code to convert each of the resulting
time series into a data frame and add the day of the centralities. The
`snafun` can compute other centrality measures in the same way e.g.,
information centrality, Bonacich Power Centrality, Harary Graph
Centrality, Bonacich Power Centrality among others.

```{r}
Closeness_Centrality <- tSnaStats(
  Active_Network,
  snafun = "closeness",
  start = 1,
  end = 73,
  time.interval = 1,
  aggregate.dur = 1,
  gmode = "graph")

Betweenness_Centrality <- tSnaStats(
  Active_Network,
  snafun = "betweenness",
  start = 1,
  end = 73,
  time.interval = 1,
  aggregate.dur = 1,
  gmode = "graph")

Eigen_Centrality <- tSnaStats(
  Active_Network,
  snafun = "evcent",
  start = 1,
  end = 73,
  time.interval = 1,
  aggregate.dur = 1,
  gmode = "graph")
```

Reachability is another important measure that temporal networks offer.
You can calculate who, when, and after how many steps an interaction
reaches from a certain vertex to another or to every other node in the
network (if it at all does). In the next code, we compute the forward
pathway (earliest reachable node) from node 44 (one of the course
facilitators) using the function `tPath`. The output is a time series
with all the time distance values and the number of steps. 

```{r}
FwdPathway <- tPath(
  Active_Network,
  v = 44,
  start = 0,
  graph.step.time = 7,
  end = 30,
  direction = "fwd")

FwdPathway |> as_tibble()
```

More importantly, we can plot the hierarchical path from the given node, by
simply using `plot` function, see @fig-fwdpathway.

```{r fig.width=6, fig.height=4.2, fig.cap="A forward pathway (earliest reachable node) pathway of interactions with node 44", echo=2}
#| label: fig-fwdpathway
#| out-width: 1000px
par(mar = c(0,0,0,0))
plot(FwdPathway)
```

We may also use `Graphviz` to make the plot look better and hierarchical (@fig-fwdpathway-gvizplotPaths).

```{r fig.width=14, fig.height=9, fig.cap="An improved forward pathway with Graphviz", fig.dpi=900}
#| label: fig-fwdpathway-gvizplotPaths

plot(FwdPathway, edge.lwd = 0.1, vertex.col= "blue", pad = -4,
     coord=network.layout.animate.Graphviz(as.network(FwdPathway), 
                   layout.par = list(gv.engine='dot',
                              gv.args = '-Granksep=2')))
```

Another option is to plot the network diffusion or transmission
hierarchical tree with generation time vs. clock/model time using
`transmissionTimeline` function as in @fig-transmission-timeline. For more on these
functions, readers are invited to read the function manuals and for
usage, these papers offer a starting point
[@Saqr_Peeters_2022;@Saqr_Peeters_Viberg_2021].

```{r fig.width=8,fig.height=5,fig.cap="Transmission hierarchical tree showing the earliest forward interaction with node 44",fig.align="center"}
#| label: fig-transmission-timeline
#| out-width: 1200px
transmissionTimeline(FwdPathway, jitter = F, displaylabels = TRUE, 
                    main = "Earliest forward path" )
```

Another useful package that offers a wealth of graph level measures is
`tErgmStats`, you may need to consult the help files which are
available by using the command `?tErgmStats`. 
One of the important functions that we can try here is the `nodemix`. We can use nodemix to
examine who and when different actors interact with each other, see here
for an example where the authors examined how low and high achievers mix
with each other and with the teachers [@Saqr_Nouri_2020]. The next
code demonstrates how to compute the mixing patterns between expertise
levels. We then convert the time series as a dataframe, clean the names
and then plot the results as demonstrated in @fig-mix-exp.

```{r, fig.cap='Mixing patterns between expertise levels and the teachers.', fig.align="center",fig.width=7,fig.height=3}
#| label: fig-mix-exp
Mix_experience <- tErgmStats(Active_Network,
  "nodemix('expert_level')",
  start = 1,
  end = 73,
  time.interval = 1,
  aggregate.dur = 1)

Mixing <- as.data.frame(Mix_experience)

colnames(Mixing) <- gsub("mix.expert_level.", "", colnames(Mixing))

Mixing$Day <- 1:73

Mixing_long= pivot_longer(Mixing, contains("."))

names(Mixing_long)= c("Day", "Mixing", "Frequency")

ggplot(Mixing_long, aes(Day, Frequency, group = Mixing, color = Mixing)) + 
  geom_line(alpha = .95) + theme_bw()
```

# Discussion

Learning can be viewed as relational, interdependent, and temporal and therefore, methods that account for such multifaceted dynamic processes are required [@Saqr_Lopez-Pernas_2023;@Saqr_Peeters_Viberg_2021]. We
have shown the main advantages of temporal networks and the potentials it offers for modeling dynamic learning processes. These potentials or features can facilitate the modeling of the complex natural processes--including the emergence, evolution, diffusion or disappearance of learners' activities, communities or social processes that unfold over time. Such features can augment the existing analytics method and help shed light on many learning phenomena [@Saqr_Lopez-Pernas_2022a]. Taking advantage of time dynamics allows us temporal evolution of co-construction of knowledge, the flow of information and the building of social relationships, to name a few
examples. What is more, temporal networks allow the longitudinal
modeling and analysis of interactions across longer periods of time
e.g., full duration of a course, project or meeting using
time-respecting paths [@Saqr_Nouri_2020;@Saqr_Peeters_2022].

There are several methods that can harness the temporal dimensions of a
learning process, e.g., process and sequence mining, time series methods
and epistemic network analysis [@Lopez-Pernas_Saqr_2021;@Peeters_Saqr_Viberg_2020]. While such
methods have given a wealth of information and insights about learning processes, they fall short when it comes to the relational aspects [@Saqr_Peeters_2022]. We review here and in short the main differences between such methods of temporal networks. Process mining is a method for the discovery and modeling of a temporal process [@Saqr_Lopez-Pernas_2023;@Vartiainen_Lopez-Pernas_Saqr_Kahila_Parkki_Tedre_Valtonen_2022].Yet, the relational aspect is completely ignored. The case is similar for sequence mining where the time-ordered sequences are modeled regardless of the theri interactions [@Heikkinen_Lopez-Pernas_Malmberg_Tedre_Saqr;@Lopez-Pernas_Saqr_2021;@Saqr_Lopez-Pernas_Jovanović_Gašević_2023]. Epistemic network analysis is another method that allows the study of co-temporal interactions. However, the "temporal aspect" is limited to combining data within a temporal window and later modeling the interactions as a static network. Put another way, Epistemic network analysis is a special type of static networks where edges are defined based on co-occurrence [@Elmoazen_Saqr_Tedre_Hirsto_2022]. For a comparison between the various methods see [@Saqr_Peeters_Viberg_2021].

# Learning resources

A good place to start is to get acquainted with the cited research in
the literature review section. Other good references could be the
methodological paper that gives a detailed overview of temporal networks
which some parts of this chapter has been built around it
[@Saqr_Lopez-Pernas_2022b]. There are few, yet very informative
tutorials that we can suggest, most notable are the tutorials by
[@Brey_2018] and [@Bender-deMoll_2016]. The packages used in
this chapter have very informative manuals:
TSNA[@Bender-deMoll_Morris_2016], NDTV[@Bender-deMoll_2018] and
networkDynamic[@Butts_Leslie-Cook_Krivitsky_Bender-Demoll_2014].
Some seminal papers can be recommended here, especially the following
papers and books.

-   Holme, P. (2015). Modern temporal network theory: a colloquium.
    European Physical Journal B, 88(9).

-   Holme, P., & Saramäki, J. (2019). A Map of Approaches to Temporal
    Networks (pp. 1--24).

-   Holme, P., & Saramäki, J. (Eds.). (2019). Temporal network theory
    (Vol. 2). New York: Springer.

# References

::: {#refs}
:::
